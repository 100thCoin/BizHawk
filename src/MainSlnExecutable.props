<Project>
	<Import Project="MainSlnCommon.props" />
	<PropertyGroup>
		<!-- Output path will contain the executable along with all its dependencies. We copy the executable up one directory up later on.
			This allows us to have the executable dependencies automagically copied over to our dll folder while still keeping the executable in the output folder. -->
		<OutputPath>$(MSBuildProjectDirectory)/../../output/dll/</OutputPath>
		<ExecFilesDest>$(MSBuildProjectDirectory)/../../output/</ExecFilesDest>
		<!-- Setting TargetName changes the output file name while preserving the AssemblyName -->
		<TargetName>$(MSBuildProjectName.Substring($([MSBuild]::Add($(MSBuildProjectName.LastIndexOf('.')), 1))))</TargetName>
		<!-- This also doesn't actually change where the executable is output, rather it's just a hint to the IDE to know where the executable is (since we move it). -->
		<TargetPath>$(ExecFilesDest)$(TargetName).exe</TargetPath>
	</PropertyGroup>
	<ItemGroup>
		<!-- This is somewhat wasteful for DiscoHawk, but it still relies on some unmanaged libraries
			Note that LinkBase is simply something added to OutputPath, it doesn't replace it -->
		<None Include="$(MSBuildProjectDirectory)/../../Assets/**/*.*" LinkBase=".." CopyToOutputDirectory="PreserveNewest" />
	</ItemGroup>
	<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
		<OutputType>Exe</OutputType>
	</PropertyGroup>
	<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
		<OutputType>WinExe</OutputType>
	</PropertyGroup>
	<Target Name="PostBuild" AfterTargets="PostBuildEvent">
		<ItemGroup>
			<ExecFilesFromExecProj Include="$(OutputPath)$(TargetFileName).*" /> <!-- note: doesn't include the .xml file (although we wouldn't want to rename/move that) -->
		</ItemGroup>
		<Move SourceFiles="@(ExecFilesFromExecProj)" DestinationFolder="$(ExecFilesDest)" />
		<MakeDir Directories="$(ExecFilesDest)ExternalTools;$(ExecFilesDest)Firmware;$(ExecFilesDest)Tools" />
	</Target>
</Project>
